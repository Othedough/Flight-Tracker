Archived code snippets

from_input method for flightGroupClass

@classmethod
    def from_input(cls):
        # from_input is an alternative constructor that allows the user to populate an instance of the class with input 
        # as opposed to instatiating it inline as one normally would. " instanceVariable = FlightGroup.from_input " 
        # For more detail on this process refer to file "Methods - Class, Static, Regular" from the notes included 
        
        # Following loop generates the list "origins" to be passed into 
        temp = []
        while input("Add travelers in this Group? y/n: ") != 'n': # this loop is the piece that allows the user to input multiple airports as origins
            temp.append([input("Enter departing Airport Code:  "), input("How many travelers will be departing from this airport:  ")])
        
        #Returns the necessary arguments to instantiate the class instance
        return cls(
            input("Enter destination Airport Code:  "),
            # Currently the following three do nothing so we are going to automatically pass a useless integer in. 
            #input("Enter the Date you would like to depart:   "),
            "December 10th",
            #input("Enter the Date you would like to return:   "),
            "December 20th",
            #input("How many days would you like to stay:    "),
            10,
            temp
        )


from_file method for flightGroupClass
    @classmethod
    def from_file(cls):
        with open('flightGroupData.pkl', 'rb') as FGhandler:
            a = pickle.load(FGhandler)
            print("\n")
            return a


A unit test for the from_file method that used to be included in flightGroupClassMk2

def test_from_file(self):
        result = flightGroupClassMk2.flightGroup.from_file()
        self.assertIsInstance(result.destination, str)
        self.assertIsInstance(result.departDate, str)
        self.assertIsInstance(result.returnDate, str)
        self.assertIsInstance(result.stayRange, int)
     
        self.assertIsInstance(result, flightGroupClassMk2.flightGroup)

        # Currently this will only work if the pkl file is not empty
        # I should later add a check to make certain that the file isnt empty before checking



 # Selects every row from the flightgroups table, we are preparing to refresh the pickle jar
    cursor.execute("SELECT * FROM flightgroups")
    count = 1

    # Creating a new handle instance to load flight groups into from the flightgroups table
    newhandle = groupHandlerClass.handler()

    # Now we are iterating over rows, preparing to extract data from the row
    for i in cursor:
        # Now we create a blank variable, a list which we will use to pass create a new flightGroup from
        flightGroupArguments = []
        for j in i:
            flightGroupArguments.append(j)
        
        cursor2 = db.cursor(buffered=True)
        
        temptablename = str(i[0].removesuffix('@gmail.com'))
        
        tempstring = "SELECT * FROM " + temptablename
        
        cursor2.execute(tempstring)
        tempOriginsList = []
        for k in cursor2:
            tempOriginsList.append(k)
        tempflightgroup = flightGroupClassMk2.flightGroup(
            flightGroupArguments[3], flightGroupArguments[1],
            flightGroupArguments[2], (flightGroupArguments[4],
                                      flightGroupArguments[5]), flightGroupArguments[0] + "@gmail.com",
            tempOriginsList)
        newhandle.groups.append(tempflightgroup)
        newhandle.save()




cursor.execute("SELECT * FROM flight_group_airport_list WHERE email='" + group[0] + "'")
            itineraries = cursor.fetchall()
            for itinerary in itineraries:
                cursor.execute("SELECT * FROM iata_iata_date_price WHERE iata1=%s and iata2=%s and date=%s", (group[3], group[1]), utility.date_time_to_str(day))
                prices = cursor.fetchall()
                for pair in prices:
                    priceDeparture += pair[3]
                    priceReturn += pair[4]
            cursor.execute("UPDATE flight_group_daily_price SET price_departure=%s WHERE email=%s and date=%s", (priceDeparture, group[0], utility.date_time_to_str(day)))
            cursor.execute("UPDATE flight_group_daily_price SET price_return=%s WHERE email=%s and date=%s", (priceReturn, group[0], utility.date_time_to_str(day)))